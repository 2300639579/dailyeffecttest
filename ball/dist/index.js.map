{"version":3,"sources":["webpack:///webpack/bootstrap 83056af8f444a37b0a0a","webpack:///./index.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA,SAAQ,gBAAgB;AACxB,SAAQ,WAAW;;AAEnB;AACA;AACA,sBAAqB;AACrB;;AAEA,wBAAuB;AACvB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2BAA0B;;AAE1B;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,oEAAmE;AACnE;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS,wBAAwB;AACjC;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yB;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA,kB;AACA;AACA;AACA;AACA;AACA,kCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;;AAEA;;AAEA,gCAA+B;AAC/B,gCAA+B;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,wBAAuB,SAAS;AAChC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;;AAEA,gDAA+C,QAAQ;AACvD;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA,c","file":"index.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 83056af8f444a37b0a0a","import {Vector2 as Vec2} from './vec2.js';\nimport {TIME, Time} from './time.js';\n\nimport Stats from './stats.js';\nvar stats = new Stats();\nstats.showPanel( 0 ); // 0: fps, 1: ms, 2: mb, 3+: custom\ndocument.body.appendChild( stats.dom );\n\nlet obstruction = 0.01; // 空气阻力\nlet bigRaduis = 15;\nlet smallRaduis = 10;\n\nclass Ball {\n    constructor(options) {\n        let defaults = {\n            initPosition: new Vec2(),\n            radius: 15,\n            initV: new Vec2, // 初始速度\n        };\n\n        for (let key in defaults) {\n            options[key] = options[key] || defaults[key];\n        }\n        this.position = options.initPosition.clone();\n        this.v = options.initV;\n        this.a = new Vec2; // 加速度\n\n        this.options = options;\n    }\n\n    update(delta) {\n\n        let second = delta * 0.001;\n        let options = this.options;\n\n        this.v.add(this.a.clone().multiplyScalar(second));\n        \n        this.v.sub(this.v.clone().setLength(obstruction * second)); // 阻力减速\n        this.position.add(this.v.clone().multiplyScalar(second));\n        // console.log(this.position);\n    }\n\n    draw(ctx, opacity, blur) {\n\n        let options = this.options;\n\n        opacity = Math.min(opacity, 1);\n\n        ctx.save();\n\n        // ctx.shadowColor = 'red';\n        // ctx.shadowBlur = blur;\n        ctx.globalAlpha = opacity;\n        ctx.fillStyle = 'red';\n\n        ctx.beginPath();\n        ctx.arc(this.position.x, this.position.y, options.radius, 0, Math.PI * 2);\n        ctx.fill();\n\n\n        // 中间透明\n        \n        /*if (typeof this.isBreakBall) {\n            let grd = ctx.createRadialGradient(this.position.x, this.position.y, 0, this.position.x, this.position.y, options.radius * 0.8);\n            grd.addColorStop(0, 'rgba(255,0,255,0.2)');\n            grd.addColorStop(1, 'rgba(255,0,255,0)');\n            \n            ctx.globalAlpha = (1 - opacity) * 0.5;\n            ctx.globalCompositeOperation = 'destination-out';\n            ctx.fillStyle = grd;\n            ctx.beginPath();\n            ctx.arc(this.position.x, this.position.y, options.radius, 0, Math.PI * 2);\n            ctx.fill();\n        }*/\n\n        ctx.restore();\n    }\n\n    die() {\n        //\n    }\n}\n\nclass Connection {\n    constructor(ball1, ball2) {\n        this.maxDis = (ball1.options.radius + ball2.options.radius) * 1.5;\n\n        this.isDie = false;\n\n        this.isSeparate = false;\n        this.ball1 = ball1;\n        this.ball2 = ball2;\n\n    }\n\n    update() {\n        this.isSeparate = this.isSeparate || (new Vec2().subVectors(this.ball1.position, this.ball2.position)).length() > this.ball1.options.radius + this.ball2.options.radius + 10;\n        // console.log(this.isSeparate);\n    }\n\n    calPoints(c1, r1, c2, r2, v, h, max) {\n        var pi2 = Math.PI / 2;\n        var c2ToC1 = new Vec2().subVectors(c1, c2);\n        var d = c2ToC1.length();\n        var u1, u2;\n\n        function getVec2(radians, length) {\n            return new Vec2(-Math.cos(radians), -Math.sin(radians)).setLength(length);\n        }\n\n        if (r1 == 0 || r2 == 0)\n            return;\n        if (d > max || d <= Math.abs(r1 - r2)) {\n            return;\n        } else if (d < r1 + r2) { // case circles are overlapping\n            u1 = Math.acos((r1 * r1 + d * d - r2 * r2) /\n                    (2 * r1 * d));\n            u2 = Math.acos((r2 * r2 + d * d - r1 * r1) /\n                    (2 * r2 * d));\n        } else {\n            u1 = 0;\n            u2 = 0;\n        }\n\n        var angle1 = c2ToC1.angle();\n        var angle2 = Math.acos((r1 - r2) / d);\n        var angle1a = angle1 + u1 + (angle2 - u1) * v;\n        var angle1b = angle1 - u1 - (angle2 - u1) * v;\n        var angle2a = angle1 + Math.PI - u2 - (Math.PI - u2 - angle2) * v;\n        var angle2b = angle1 - Math.PI + u2 + (Math.PI - u2 - angle2) * v;\n        var p1a = c1.clone().add(getVec2(angle1a, r1));\n        var p1b = c1.clone().add(getVec2(angle1b, r1));\n        var p2a = c2.clone().add(getVec2(angle2a, r2));\n        var p2b = c2.clone().add(getVec2(angle2b, r2));\n\n        // define handle length by the distance between\n        // both ends of the curve to draw\n        var totalr = (r1 + r2);\n        var d2 = Math.min(v * h, new Vec2().subVectors(p1a, p2a).length() / totalr);\n\n        // case circles are overlapping:\n        d2 *= Math.min(1, d * 2 / (r1 + r2));\n\n        r1 *= d2;\n        r2 *= d2;\n\n        let handle1 = p1a.clone().add(getVec2(angle1a - pi2, r1));\n        let handle2 = p2a.clone().add(getVec2(angle2a + pi2, r2));\n        let handle3 = p2b.clone().add(getVec2(angle2b - pi2, r2));\n        let handle4 = p1b.clone().add(getVec2(angle1b + pi2, r1));\n        return [p1a, p2a, p2b, p1b, handle1, handle2, handle3, handle4];\n    }\n\n    draw(ctx, opacity, blur) {\n        let keyPoints = this.calPoints(\n            this.ball1.position.clone(), \n            this.ball1.options.radius,\n            this.ball2.position.clone(), \n            this.ball2.options.radius, \n            0.3,\n            5.4,\n            this.maxDis\n        );\n\n        ctx.save();\n        if (keyPoints) {\n            // ctx.shadowColor = 'red';\n            // ctx.shadowBlur = blur;\n            ctx.globalAlpha = opacity;\n            ctx.globalCompositeOperation = 'source-over';\n            ctx.fillStyle = 'red';\n            ctx.beginPath();\n            ctx.moveTo(keyPoints[0].x, keyPoints[0].y);\n            ctx.bezierCurveTo(keyPoints[4].x, keyPoints[4].y, keyPoints[5].x,keyPoints[5].y, keyPoints[1].x, keyPoints[1].y);\n            ctx.lineTo(keyPoints[2].x, keyPoints[2].y);\n            ctx.bezierCurveTo(keyPoints[6].x, keyPoints[6].y, keyPoints[7].x,keyPoints[7].y, keyPoints[3].x, keyPoints[3].y);\n            ctx.lineTo(keyPoints[0].x, keyPoints[0].y);\n\n            ctx.fill();\n        }\n        ctx.restore();\n    }\n\n    die() {\n        this.isDie = true;\n        this.ball1 = null;\n        this.ball2 = null;            \n    }\n}\n\nclass BreakBall {\n    constructor(options) {\n        let defaults = {\n            maxOpacity: 1,\n            blur: 0,\n\n            bornPos: new Vec2(),\n            bornA: new Vec2(5, 5), // 出生加速\n            bornADur: 1000, // 出生加速耗时\n\n            breakTime: 2000, // 分裂时间\n            breakA: 5, // 标量，方向在运行的时候确定\n            breakADur: 1000, // 分裂加速耗时\n            destoryDur: 1000, // 消亡耗时\n        };\n\n        for (let key in defaults) {\n            options[key] = options[key] || defaults[key];\n        }\n        this.options = options;\n\n        // 0 born\n        // 1 a done\n        // 2 break\n        // 3 break a done\n        // 4 die\n        this.status = 0; \n\n\n        this.timePass = 0;\n        this.separateTime = 0;\n        this.opacity = 1;\n        this.blur = options.blur;\n\n\n        this.ball1Radius = bigRaduis * (1.2 - Math.random() * 0.4);\n        this.ball2Radius = smallRaduis * (1.2 - Math.random() * 0.4);\n\n        this.ball1 = new Ball({\n            initPosition: options.bornPos.clone(),\n            radius: this.ball1Radius,\n            initV: new Vec2, // 初始速度\n        });\n        this.ball1.a = options.bornA;\n        this.ball2;\n        this.connection;\n    }\n\n    update(delta) {\n        let options = this.options;\n        let second = delta / 1000;\n        let opacity = 1;\n\n        this.timePass += delta;\n\n        switch (this.status) {\n            case 0: \n                if (this.timePass < options.bornADur) {\n                    opacity = this.timePass / options.bornADur;\n                } else {\n                    this.status = 1;\n                    this.ball1.a = new Vec2;\n                }    \n                break;\n            case 1: \n                if (this.timePass >= options.breakTime) {\n                    this.status = 2;\n                    this.break(); // 生成 ball2, 设置分裂加速度\n                }\n                break;\n            case 2: \n                // console.log(this.ball1.v, this.ball2.v);\n                // console.log(this.ball1.v, this.ball2.v);\n                // console.log(this.ball1.position, this.ball2.position);\n                if (this.timePass >= options.breakTime + options.breakADur) {\n                    this.status = 3;\n                    this.ball1.a = new Vec2;\n                    this.ball2.a = new Vec2;\n                }\n                break;\n            case 3: \n                if (!this.separateTime && this.connection.isSeparate) {\n                    this.separateTime = this.timePass;\n                }\n                if (this.separateTime) {\n                    if (this.timePass < this.separateTime + this.options.destoryDur) {\n                        opacity = 1 - (this.timePass - this.separateTime) / \n                                    this.options.destoryDur;\n                    } else {\n                        this.status = 4;\n                        this.die();\n                    }\n                }\n                break;\n        }\n\n        // console.log(this.status, opacity);\n        this.opacity = Math.min(opacity, 1) * this.options.maxOpacity;\n\n        this.ball1 && this.ball1.update(delta);\n        this.ball2 && this.ball2.update(delta);\n        this.connection && !this.connection.isDie && this.connection.update(delta);\n    }\n\n    draw(ctx) {\n        this.ball1 && this.ball1.draw(ctx, this.opacity, this.blur);\n        this.ball2 && this.ball2.draw(ctx, this.opacity, this.blur);\n        this.connection && !this.isDie && this.connection.draw(ctx, this.opacity, this.blur);\n    }\n\n    break() {\n        this.ball2 = new Ball({\n            initPosition: this.ball1.position,\n            radius: this.ball2Radius,\n            initV: new Vec2, // 初始速度            \n        });\n\n        let breakA1 = new Vec2(Math.random(), Math.random());\n        breakA1.setLength(this.options.breakA);\n        \n        let breakA2 = breakA1.clone().multiplyScalar(-1);\n\n        this.ball1.a = breakA1;// 分裂加速度\n        this.ball2.a = breakA2;// 分裂加速度\n        this.connection = new Connection(this.ball1, this.ball2);\n    }\n\n    die() {\n        this.isDie = true;\n        this.ball1.die();\n        this.ball2.die();\n        this.connection.die();\n        this.ball1 = null;\n        this.ball2 = null;\n        this.connection = null;\n    }\n}\n\nclass Painter extends Time {\n    constructor(cvs) {\n        super();\n        this.cvs = cvs;\n        this.width = cvs.width;\n        this.height = cvs.height;\n        this.ctx = this.cvs.getContext('2d');\n\n        this.tick;\n\n        this.breakBalls = [];\n\n        this.offCvs = document.createElement('canvas');\n        this.offCvs.width = this.width;\n        this.offCvs.height = this.height;\n        this.offCtx = this.offCvs.getContext('2d');\n\n        let grd=this.offCtx.createLinearGradient(0, 0, this.width, 0);\n        for (let i = 0; i <= 10; i++) {\n            grd.addColorStop(i/10, i % 2 === 0 ? '#0678d0' : '#1bb4ba');\n        }\n        this.offCtx.fillStyle = grd;\n        this.offCtx.fillRect(0, 0, this.width, this.height);\n\n        this.maxBallCount =  6;\n    }\n\n    start() {\n        this.tick = this.addTick(this.tick);\n    }\n\n    tick(delta) {\n        stats.update();\n        if (this.breakBalls.length < this.maxBallCount) {\n\n            let maxOpacity = Math.random() + 0.8;\n            let blur = (Math.random() * 8) | 0;\n            let bornPos = new Vec2(\n                this.width * 0.1 + Math.random() * this.width * 0.3 + (Math.random() > 0.5 ? this.width * 0.6 : 0), \n                Math.random() * this.height * 0.3 + this.height * 0.3\n            );\n            let bornA = new Vec2(Math.random() - 0.5, Math.random()-0.5).setLength(Math.random() * 20);\n\n            let aniTime = Math.random() * 3000 + 5000;\n            let bornADur = aniTime * 0.2;\n            let breakTime = aniTime * 0.4;\n            let breakADur = aniTime * 0.2;\n            let breakA = 8 + Math.random() * 6;\n            let destoryDur = Math.random() * 300 + 1000;\n\n            this.breakBalls.push(new BreakBall({\n                maxOpacity,\n                blur,\n\n                bornPos,\n                bornA, // 出生加速度\n                bornADur, // 出生加速耗时\n\n                breakTime, // 分裂时间\n                breakA, // 标量，方向在运行的时候确定\n                breakADur, // 分裂加速耗时\n                destoryDur // 消亡耗时\n            }));\n        }\n        this.ctx.save();\n        this.ctx.clearRect(0, 0, this.width, this.height);\n\n        for(let i = this.breakBalls.length - 1; i >= 0; i--) {\n            if (this.breakBalls[i].isDie) {\n                this.breakBalls.splice(i, 1);\n            } else {\n                this.breakBalls[i].update(delta);\n                this.breakBalls[i].draw(this.ctx);\n            }\n        }\n\n        this.ctx.globalCompositeOperation = \"source-in\";\n        this.ctx.drawImage(this.offCvs, 0, 0);\n        // console.log(balls.length);\n        this.ctx.restore();\n    }\n}\n\n\n\nlet cvs = document.createElement('canvas');\n\ncvs.width = 1920;\ncvs.height = 1079;\n\ndocument.body.appendChild(cvs);\n\nlet painter = new Painter(cvs);\n\npainter.start();\nTIME.start();\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./index.js\n// module id = 0\n// module chunks = 0"],"sourceRoot":""}